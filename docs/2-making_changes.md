# Making changes and changing file states

## git status

Lets do some actual work. One of the most common commands to use on a day to day basis is `git status`. Try running it right now with a shell session open in this repo. What do you see? Probably something like this:

```bash
➜  git-training-grounds git:(main) git status
On branch main
nothing to commit, working tree clean
```

If you see a console output like this congrats, you've done nothing so far! But even within this basic output theres actually a lot of info. Look at each line.

```bash
On branch main
```

Tells you right away what branch you're on. More on what a branch is later but know that this command can easily remind you of what branch you're working on no matter your shell. Your code editor likely has a part of the UI that gives you the same info because it's running a `git status` in the background.

```bash
nothing to commit, working tree clean
```

This output tells you that there are no changes relative to the last commit present in the repo, meaning you haven't changed anything. Let's change that and see what happens. In the directory `/src/` you'll see a file called `modify_me.py`. It's tracked with `git`. Meaning if you make changes to it you can view those changes with `git`. Right now delete or change something in there and save the file. Anything. Run a `git status` again. What do you see? Probably something like this:

```bash
➜  git-training-grounds git:(main) ✗ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   ../src/modify_me.py

no changes added to commit (use "git add" and/or "git commit -a")
```

One interesting note here is the path in:

```bash
modified:   ../src/modify_me.py
```

If you ran a `git status` while inside `/docs/` you will see the `..` before the path. If you run it from the root of the project you won't see the `..`. `git` changes the paths of a `git status` relative to directory you ran it in.

Now you'll probably be asking yourself "so what?". Good question. Here's were the useful features start with `git`, via a tool called `diff` (difference) that lets you see not just that a file changed but _what_ changed.

## Seeing how things changed (git diff)

### The really practical stuff

With your changes to the `modify_me.py` file still in place run

```bash
git diff ../src/modify_me.py
```

You might need to adjust that file path depending what directory you're sitting in. You'll get a funny error about something being fatal if you mess up the path. `git` can be a little dramatic sometimes. Once successful you'll see something like this example from a project:

```bash
diff --git a/linter/src/main.rs b/linter/src/main.rs
index 7383g39..9bjb5a5 100644
--- a/linter/src/main.rs
+++ b/linter/src/main.rs
@@ -222,7 +222,6 @@ fn main() {
 
     match args.command {
         Commands::Lint { file_path } => {
-            // Read from stdin
             match read_stdin_to_string(io::stdin()) {
                 Ok(contents) => {
                     process_contents(&file_path, contents, &file_extensions);
(END)
```

Theres a lot going on here along with the fact that your terminal probably looks funny compared to how you're used to seeing it. Congrats you're now using something called a "terminal pager" which `git` uses for the more interactive features. To exit the screen you're seeing in the terminal hit `q` on your keyboard for "quit".

A pager is a command line tool for more easily viewing a lot of content like the kind generated by a `diff` all from the command line by rendering "pages" in the limited interface of a terminal. You will also see it when viewing branches which we'll get to later. Just know for now you can get out of it with "q" when you're done viewing the `diff` and also know that like most things in `git` you can customize it later to use different pager tools and even display content in more visually appealing ways. I'll leave that exercise up to you if the default pager isn't good enough for your refined tastes.

Reopen the diff if you closed it and look at what you see. In the case of my `diff` above I deleted the line

```rust
// Read from stdin
```

in the source code, and that difference is indicated via a `-` on the far left side of the `diff` output where the deletion happened.  If you made a change to a line (vs an outright deletion) you'll see a `-` indicating the previous state of that line (per the last commit) and a `+` indicating the new current state. Editing / change something in the file if you haven't already and run the same same `diff` command to see this way of representing changes. Likewise pure additions will be indicated with just a `+`.

### The more detailed stuff (optional)

There's other interesting things happening in the `diff` output that will help you understand changes to your file. Every diff will be a variant on this same thing, often with more lines of content repeating the same info across multiple pages of the pager.

```bash
diff --git a/linter/src/main.rs b/linter/src/main.rs
index 7383g39..1c98f0f 100644
--- a/linter/src/main.rs
+++ b/linter/src/main.rs
@@ -222,7 +222,7 @@ fn main() {
 
     match args.command {
         Commands::Lint { file_path } => {
-            // Read from stdin
+            // Read from stdin I MADE A CHANGE HERE
             match read_stdin_to_string(io::stdin()) {
                 Ok(contents) => {
                     process_contents(&file_path, contents, &file_extensions);
(END)
```

Here's a `diff` where I updated a comment. We're going to work top down of the whole output now.

```bash
diff --git a/linter/src/main.rs b/linter/src/main.rs
```

This reminds you of what file you're looking at. Diffs don't have to be just one file so this may come in handy if your `diff` is targeted at a directory. In this case we're looking at a `diff` powered by `git`, of the initial state `a` of the file `main.rs`, versus its new state `b`.

---

```bash
index 7383g39..1c98f0f 100644
```

This line is really getting into the nuts and bolts of how `git` works. The `index 7383g39..1c98f0f` tells you the index hash of the initial state of the file (`7383g39`) and the new index hash (`1c98f0f`). The "hash" of a file is powered by the SHA-1 algorithm to give a numerical value of the file state and is not something you will generally care about the deep implementation details of, but you will probably copy paste hash codes a lot for powering other commands. Basically, if a file has the same hash code at two points in time, it is unchanged, while different hash codes means different file contents and thus a diff is generated. This hash system is how `git` determines if a file changed.

The `100644` indicates the file mode with regular file read/write permissions. You will almost never care about this but feel free obviously to research it deeper if you're curious or suspect you may be working with files in the future where read/write permissions are important and might change either intentionally or unintentionally.

---

```bash
--- a/linter/src/main.rs
+++ b/linter/src/main.rs
```

This bit tells you about the file paths before and after the change. In our case, the paths don't change.

---

```bash
@@ -222,7 +222,7 @@ fn main() {
```

This bit is actually pretty interesting and is used to power visual tools for more easily analyzing file changes. We know from the previous output we're looking at the file `main.rs`, but starting with the first `@@` this output tells us that the initial state of the diff starts at line 222 and spans 7 lines, and in the new state of the file also starts at line 222 and spans seven lines. This is pretty straight forward in this case, but in situations of large changes you may see the line number and span change a lot. Try inserting a bunch of blank lines in this doc and see how that changes this line specifically. This info can be incredibly useful in mentally mapping how code has moved around in a file before and after.

The second `@@` block tells us some additional context, specifically that the changes occurred within the `main()` function of the code.

---

I already went over the change representation in the previous section so I'll skip that here.

---

```bash
(END)
```

This symbol tells you when the `diff` output has ended. You are probably thinking "Wow really, you think I couldn't figure that out on my own?" but in cases of many many changes in a file the "pager" will page down showing you more output and it may not be immediately apparent that theres more to see. You are not done viewing the `diff` until you see `(END)` so keep that in mind when viewing large changes. You can often page down using your scroll input on your mouse or trackpad, or use the arrow keys to go line by line, or space bar to skip page by page.

## Reverting things

You've probably messed up some files pretty good by now experimenting. If not go mess some things up anywhere in the project (preferably not the next few paragraphs though). Keep it that way and don't rely on the "undo" button of your editor to fix it. Instead we're going to use `git` itself to revert the state of the file to its last saved commit.

In the terminal run

```bash
git status
```

to orient yourself to what changes are currently in the repo. Now to revert one file to its previous state you can run

```bash
git restore /path/to/your/file
```

or you can also use a trick of the `checkout` command by feeding it `--` to do the same thing, as shown below

```bash
git checkout -- path/to/your/file
```

And this will revert the file to its state in the last commit. You can also feed these commands a whole directory instead of just one file to do the same thing to a directory of files.

There is another way to revert a whole directory to its last state for all files in something called both the "staging area" and the "working tree/directory". More details on those to come, just know that this little command below is the nuclear solution to resetting a source controlled project. Use only when you really want EVERYTHING reset.

```bash
git reset HEAD --hard
```

The third argument in this command is the commit being reset to. In this case `HEAD`, which automatically refers to the most recent commit on your current branch. If you have a hash code for _any_ commit you can reset to its state using this command and substituting in the commit hash where `HEAD` is. You can also use branch names to reset to a specific branch.

Rule of thumb, when you see `--hard` you know you're about to do something powerful. Proceed with caution. `git` has docs on this reset command [here](https://git-scm.com/docs/git-reset#Documentation/git-reset.txt-emgitresetemltmodegtltcommitgt) if you're curious.

### Exercise: "put it back the way you found it"

Try running the `git restore path/to/your/file` command against one file with changes and see what happens, then change a bunch more files and run the `git reset HEAD --hard` command. Then once you see no changes to your repo via a `git status` and you see something about `nothing to commit, working tree clean` in the console, you're ready to move on to the next section as you're about to learn what the "working tree" is...

## The 3 states of a file according to git

Git tracks files in 3 states and you will see these states come up again and again as you use git. The usual flow of work is diagrammed below.

```plaintext
+-------------------+---------------------+-------------------+
|   Working Tree    |   Staging Area      |    Repository     |
+-------------------+---------------------+-------------------+
| 1. Modified files |                     |                   |
| 2. `git add`  --> | 3. Staged changes   |                   |
|                   | 4. `git commit` --> | 5. Saved changes  |
+-------------------+---------------------+-------------------+
```

### The Working Tree

**You may see documentation and discussions that refer to something called the "Working Directory". This is the same thing as the "Working Tree" mentioned above. The "Working Tree" is the term used in modern git to avoid confusion with the overlap of the word "directory" in other contexts and I will refer to it as thus from here on out.**

When you modify any file that has be previously tracked in `git` that file is now in the working tree. Its changes have not yet been stored in any way and is awaiting you to do that should you decide you want to keep those changes. You can view changes using the `git diff` tool.

### The Staging Area

Run `git add /path/to/your/file` to move your set of changes into the "Staging Area". Then run a `git status` again. What do you see? In my case working on this exact repository heres my output after moving the README file into staging

```bash
➜  git-training-grounds git:(main) ✗ git status
On branch main

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   README.md

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        docs/
        src/
```

We now have two sections of changes corresponding to the diagram above, with `Changes to be committed:` being files in the Staging Area, and `Untracked files:` being files in the Working Tree along with some example commands on how to work with them further.

Why?

The Staging Area is meant to be just that, a staging area before making a meaningful commit, although many `git` users just slam files through it without much thought. That's fine but the stage does let you do some neat tricks for preserving new work that can save you a lot of trouble in the long run vs managing commits with partial work.

Lets see that in practice.

At the end of the `README.md` file of this project add some random text and save the file. Then use `git add README.md` to add it to the stage. Now add more random text below that first set of text you added and save the file. Run a `git status`. What do you see? Probably something like this.

```bash
➜  git-training-grounds git:(main) ✗ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        modified:   README.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   README.md
```

You now have a single file with changes tracked in _two_ different places according to `git`. The first set represents changes you really want to save at some point soon via a `commit`, and you can view them via the below command

```bash
git diff --cached README.md
```

Press `q` to exit, and then run

```bash
git diff README.md
```

and you'll see your second set of changes that are in the Working Tree printed out in a diff. Here's an example:

```bash
diff --git a/README.md b/README.md
index 2bca173..da96fbc 100644
--- a/README.md
+++ b/README.md
@@ -43,3 +43,6 @@ git-training-grounds

 Then `cd` into `git-training-grounds` and if you're using VSCode with it installed on your system PATH run `code .` to open it in a new VSCode window. If you're using a different editor open up that new folder in it and open the file `git_fundamentals.md` to get started from there. Whatever editor you're using probably has either a folder history or project history so that you can easily find this cloned project again.
+
+
+SOME NEW STUFF
\ No newline at end of file
(END)
```

You can reset staged changes via `git restore --staged` and the file path, and you can reset working tree changes via `git restore` and the file path. If at any time you forget these two commands you can remind yourself at any time via a `git status` if you have staged and unstage changes. Give that a try again right now.

### Untracked vs tracked files

Newly created files have a unique state in `git` known as "untracked". This state can be a little confusing as untracked files can bypass certain blocks in `git` when switching branches that we'll get to shortly. This is by design as an untracked is file is meant to be well...untracked. In general for practical `git` usage, if you create a new file that you're sure you want to eventually source control, regardless of its content, add it via a `git add` so that it's tracked like any other file before you start working on it.

You can see untracked files in a unique part of the CLI output in a `git status`

```bash
➜  git-training-grounds git:(main) ✗ git status
On branch main

<some more git status output>

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        .gitignore
        docs/
        src/
```

Many editors and source control GUI's also color untracked files differently from files that are tracked and modified to make it more obvious when you have files that aren't yet under the management of `git`.

### Committed to the Repository

The final state of a changed file in `git` is the "Repository" state that occurs once a files changes go through a commit. This is the final "save point" of the source control workflow loop and once committed, that commit will then have a hash code, name, and datetime, and a message associated with it along with the state of the files in the project at the time of that commit.

_A note on the commit message:_ When you make a commit you enter a message along with it. What you put in this message is of great debate among the software community, but generally it's less than 120 characters very briefly describing the changes in that commit and thats a good standard to stick to. Don't just put `"."`. I've certainly been guilty of putting funny things in that message but whether that's appropriate is up to team culture. Descriptive commit messages can be helpful when traversing `git` history via the `log` (which you'll see shortly) so it's best to err on the side of helpful. There is a movement within software however called [conventional commits](https://www.conventionalcommits.org/en/v1.0.0/) that leverage a very strict structure in commit messages to power changelogs and software versions automatically.

## The whole workflow loop as an exercise

To put it all together lets work through this whole workflow and end with making a commit that we will later use to make a pull request to save your changes to the master copy and immortalize your learning forever. Before making a commit we will need to be on a new "branch" that we will eventually use to make something called a "pull request" that adds your changes to the main copy of the code. We're skipping ahead here a bit and getting a preview of things to come so bear with me if some of this isn't explained well _yet_. For now, know that a "branch" is like your own unique version of the code that you can do whatever you want with without changing the original "master/ main" copy, and a "pull request" is the process by which you merge those changes back into the master copy.

First lets double check we're on a clean copy of the master version of the code. Run a `git status` and you should see this

```bash
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
```

If not, jump back up a few sections to the various ways to revert changes to file in a repo until you are back at a clean state (some modified states will result in `git` not letting you change branches, more on that later).

Now, run this command, adding your own name where I specified "your-name-here"

```bash
git checkout -b your-name-here-training-branch
```

What you've just done is created a new branch with the name you specified at the end of the command, and switched to it. If you run a `git status` again you'll see a new branch name in the output. You are now working on your own copy of the code like a very elegant and controlled version of just making a new copy of a document. We will explore what `checkout` and `-b` really do later in the doc on [branching](3-branching_and_remotes.md).

Let's work through the above workflow about file states and end with a commit.

1. Open the file `/src/street_art.md` and add something to it. Could be anything, a quote, some ascii art, "your name was here", song lyrics, etc. Don't delete other peoples additions, just add to it.
2. Save the changes then confirm the file is tracked with `git` via a `git status` and that `git` is seeing the edit. Bonus points if you run the file through a `diff` as shown above and confirm your changes in there.
3. Now move the file from the Working Tree to the Staging Area (the commands to do these are all listed above or could be found pretty easily online).
4. To finally commit those changes once they're in the staging area run the following command:

```bash
git commit -m "first commit to Street Art"
```

And you'll see a confirmation of you're commit with a brief summary of the changes. If you didn't move your changes to the Staging Area, but instead left them in the Working Tree you'll see a message about "nothing to commit". Remember, `git` doesn't do things automatically for you, YOU need to move files into a state that indicates they're ready to commit. This is useful because sometimes there are changes you want to move into a commit (Staging Area), while leaving others in a draft state of sorts and not yet commit them (Working Tree). We will push these changes up and merge them in the coming sections. Run another `git status` to see that your Working Tree and Staging Area are all clean again now.

## Saving changes for later AKA The Stash

There is a sneaky fourth state that a files changes can be in called "stashed". This feature is very useful for when you have some changes that you will need later, but need to remove from not just the Staging Area but also from the Working Tree. You will find this most useful if you need to switch to another branch to view some changes, and then switch back. Full documentation can be found [here](https://git-scm.com/docs/git-stash) along with a more general guide [here](https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning) for this feature and its worth saving this for later, but for your average day to day work there are two main ways you can do this workflow depending on your needs.

### Unnamed stashing (stash / pop workflow)

To quickly stash some changes that you'll reapply again shortly, you use just the `stash` command without any extra arguments. Edit any file in this repo and save the file. Run a `git status` to verify those changes are in the Working Tree, and then run

```bash
git stash
```

You will note that all your changes have been reverted back to their original state. Running `stash` this way stashes _ALL_ file changes in the repo. If you need more fine grained control consult the docs as its possible to stash individual files and directories too. Your editor might have a right click option to do this also. To get your changes back simply run

```bash
git stash apply
```

And your changes have now returned. Running the `stash apply` command without any other arguments simply pops the latest stash off the list of existing stashes and applies it to your repo. That of course implies that the stash can hold more than one change set which it can, and you can view it with

```bash
git stash list
```

You likely won't see anything right now running the `list` command but it's worth remembering as it will come in handy later.

### Named stashing

To get more targeted and user friendly with your `stash` / `apply` workflow you can add a name to your stash to make it easier to differentiate in the `stash list` mentioned above. To do this, modify a file in here again, save it, and then run

```bash
git stash -m "bugfix-temp"
```

followed by a `git stash list` and you'll see your named stash in the list (in case you forgot hit `q` to exit the pager this will open). Note that this uses the same syntax for a message as a `commit`. To then apply that stash to your repo again you run

```bash
git stash apply stash^{/bugfix-temp}
```

This syntax is a little clunky as the name is just meant to make it easier to identify, while its `stash@{0}:` value seen via the `list` command is how its really meant to be applied(`{0}` tells `git` to get the first stashed item like a zero indexed array). To apply your first stash you'd run `git stash apply stash@{0}`, to apply your second stash you'd use `stash@{1}:`, etc.

## Optional implementation details

Where in the world is `git` storing all the data needed to know about these file states? Such data is stored inside a hidden directory in your repo called `.git`. If you open that up you will find all your project config and history data, logs, remotes, hooks, and other features. You will almost never go messing around in there, but if you want to see more of how `git` works, and more about your project config in general, that's where to look.

## Onwards

Open up the next section `3-branching_and_remotes.md` to get into just what a "branch" is.
